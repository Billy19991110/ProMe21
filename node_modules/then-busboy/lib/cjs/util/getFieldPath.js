"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_errors_1 = __importDefault(require("http-errors"));
const isNaN_1 = __importDefault(require("./isNaN"));
/**
 * Matches square braces notation paths
 *
 * e. g. foo[bar][0][baz]
 */
const BRACKET_EXPR = /^([^0-9[\]\n\r\t]+|\[[0-9]+\])(\[[^[\]]+\])*$/;
/**
 * Matches dot notation paths
 *
 * e. g. foo.bar.0.baz
 */
const DOT_EXPR = /^([a-z0-9_$]*)(?:\.([a-z0-9_$]*))*?$/i;
/**
 * Casts numeric keys to a number type
 *
 * @api private
 *
 * @param key
 */
const castNumKey = (key) => ((0, isNaN_1.default)(key) ? key : Number(key));
/**
 * @param {string} string
 */
const fromDotNotation = (string) => (string.split(".").map(castNumKey));
/**
 * @param string
 */
const fromSquareBracesNotation = (string) => (string.split(/[[\]]/).filter(Boolean).map(castNumKey));
/**
 * Returns fields path as array
 *
 * @param fieldname
 *
 * @throws {TypeError} when given fieldname is not a string
 * @throws {Error} on unexpected fieldname format
 *
 * @api private
 *
 * @example
 *
 * getFieldPath("foo[bar][baz]") // -> ["foo", "bar", "baz"]
 *
 * getFieldPath("foo") // -> ["foo"]
 *
 * getFieldPath("[42]") // -> [42]
 *
 * getFieldPath("root.nested") // -> ["root", "nested"]
 *
 * getFieldPath("someCollection.0.name") // -> ["someCollection", 0, "name"]
 */
function getFieldPath(fieldname) {
    if (!fieldname) {
        throw (0, http_errors_1.default)(400, "Field name cannot be empty.");
    }
    if (DOT_EXPR.test(fieldname)) {
        return fromDotNotation(fieldname);
    }
    if (BRACKET_EXPR.test(fieldname)) {
        return fromSquareBracesNotation(fieldname);
    }
    throw (0, http_errors_1.default)(400, `Incorrect field name format at: ${fieldname}`);
}
exports.default = getFieldPath;
